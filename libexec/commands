#! /bin/bash
#
# List all available commands or subcommands for a specified command

# Note that _@go.find_commands uses this insertion sort rather than `sort |
# uniq` not just because it's is more portable (to Windows), but because it's
# actually faster for the amount of data involved, since it avoids the overhead
# of launching the `sort | uniq` pipeline. Since the user's expected to invoke
# this frequently via the 'help' command and tab completion, scraping out this
# tiny bit of performance potentially matters. (And it keeps the tests fast.)
_@go.insert_name_and_script() {
  local cmd_name="$1"
  local cmd_script="$2"
  local i=0
  local current_name
  local current_script

  for ((i=${#__go_command_names[@]}; i != 0; --i)); do
    current_name="${__go_command_names[$((i-1))]}"
    current_script="${__go_command_scripts[$((i-1))]}"

    if [[ "$cmd_name" = "$current_name" ]]; then
      printf "WARNING: duplicate command $cmd_name:\n\n  %s\n  %s\n" \
        "$current_script" "$cmd_script" >&2
      return 1
    elif [[ "$cmd_name" < "$current_name" ]]; then
      __go_command_names[$i]="$current_name"
      __go_command_scripts[$i]="$current_script"
    else
      break
    fi
  done

  __go_command_names[$i]="$cmd_name"
  __go_command_scripts[$i]="$cmd_script"
}

_@go.find_commands() {
  local scripts_dir
  local cmd_script
  local cmd

  __go_longest_name_len=0
  __go_command_names=()
  __go_command_scripts=()

  shopt -s nullglob

  for scripts_dir in "$@"; do
    for cmd_script in "$scripts_dir"/*; do
      if [[ ! (-f "$cmd_script" && -x "$cmd_script") ]]; then
        continue
      fi

      cmd="${cmd_script##*/}"
      _@go.insert_name_and_script "$cmd" "${cmd_script#$_GO_ROOTDIR/}"

      if [[ "${#cmd}" -gt "$__go_longest_name_len" ]]; then
        __go_longest_name_len="${#cmd}"
      fi
    done
  done

  shopt -u nullglob

  if [[ "${#__go_command_names[@]}" -eq 0 ]]; then
    return 1
  fi
}

_@go.list_commands() {
  local cmd
  local __go_command_names

  if ! _@go.find_commands "$@"; then
    return 1
  fi

  for cmd in "${__go_command_names[@]}"; do
    echo $cmd
  done
}

_@go.summarize_commands() {
  local __go_command_names
  local __go_command_scripts
  local __go_longest_name_len

  if ! _@go.find_commands "$@"; then
    return 1
  fi

  . "$_GO_CORE_DIR/lib/command_descriptions"

  local i
  local cmd_name
  local cmd_script
  local __go_cmd_desc

  for ((i=0; i != "${#__go_command_names[@]}"; ++i)); do
    cmd_name="${__go_command_names[$i]}"
    cmd_script="${__go_command_scripts[$i]}"

    if ! _@go.command_summary "$cmd_script"; then
      __go_cmd_desc='error retrieving command summary'
    fi
    _@go.format_summary "$cmd_name" "$__go_cmd_desc" $__go_longest_name_len
  done
}

_@go.list_command_paths() {
  local __go_command_names
  local __go_command_scripts
  local __go_longest_name_len

  _@go.find_commands "$@" || return 1

  local i

  for ((i=0; i != "${#__go_command_names[@]}"; ++i)); do
    printf "%-${__go_longest_name_len}s  %s\n" \
      "${__go_command_names[$i]}" "${__go_command_scripts[$i]}"
  done
}

_@go.commands() {
  local action="list"
  case "$1" in
  --complete)  # Tab completions
    shift
    if [[ "${1:0:1}" = '-' ]]; then
      shift
    elif [[ "$#" -eq '0' ]]; then
      echo '--summaries --paths'
    fi
    ;;
  --*)
    action="${1#--}"
    shift
    ;;
  esac

  if [[ -z "$*" ]]; then
    local __go_search_paths
    _@go.set_search_paths
    set "${__go_search_paths[@]}"

  elif [[ ! -e "$1" ]]; then
    if _@go.source_builtin 'aliases' --exists "$1"; then
      return 1
    fi

    local __go_cmd_path
    if ! _@go.set_command_path_and_argv "$@"; then
      return 1
    fi

    set "${__go_cmd_path}.d"
  fi

  case "$action" in
  list)
    _@go.list_commands "$@"
    ;;
  summaries)
    _@go.summarize_commands "$@"
    ;;
  paths)
    _@go.list_command_paths "$@"
    ;;
  *)
    echo "unknown option: --$action"
    return 1
    ;;
  esac
}

_@go.commands "$@"
