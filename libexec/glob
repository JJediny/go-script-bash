#! /bin/bash
#
# Recursively find files with a specified suffix matching shell patterns
#
# Usage:
#   {{go}} {{cmd}} [--ignore <patterns>] [--compact]
#     <root-dir> <suffix> [<glob>...]
#
# Options:
#   --ignore   Colon-separated list of ignored patterns (sets Bash's GLOBIGNORE)
#   --compact  Strip <root-dir>/ prefix and <suffix> from paths
#
# Arguments:
#   <root-dir>  Directory in which to search for matching files
#   <suffix>    The file suffix match, usually an extension
#   <glob>      Pattern to filter files matching <suffix>
#
# Without <glob> arguments, lists all files matching <suffix> within <root-dir>.
# With one or more <glob> arguments, only lists files matching
# `<root-dir>/<glob><suffix>`.
#
# If <glob> contains no shell metacharacters, it will attempt to match a single
# file. If <glob> ends with a path separator, it will try to match all files
# within any matching directories.
#
# If the <suffix> or one of the <glob> arguments doesn't match any files, the
# command will return an error.
#
# The primary use case is to support the `./go test` command in selecting a
# subset of tests to run, tests which my occupy a multi-level directory
# structure. Can be used by other command scripts to provide a better user
# experience than using full paths or default filename completion by:
#
#   - restricting the search directories
#   - restricting the kinds of files matched
#   - removing the need to specify the root directory or file suffix
#
# NOTE: If a <glob> produces errors, or generally doesn't do as you expect,
# you may need to include it in quotes so it isn't expanded by the shell
# _before_ executing the {{cmd}} command.

_@go.glob_files_impl() {
  local pattern="$1"
  local full_pattern="$__go_glob_files_rootdir/$pattern"

  # This happens when the pattern contains no shell metacharacters and doesn't
  # end with a trailing slash, i.e. it matches a single file.
  if [[ -f "$full_pattern$__go_glob_files_suffix" ]]; then
    __go_glob_matches+=("$full_pattern$__go_glob_files_suffix")
    return
  fi

  shopt -s nullglob
  local matches=($full_pattern)
  shopt -u nullglob
  local match
  local corresponding

  for match in "${matches[@]}"; do
    # If a file name without the suffix matches a directory, add the file first.
    if [[ -d "$match" ]]; then
      corresponding="$match$__go_glob_files_suffix"

      # If the original pattern ends in a path separator, it won't match a
      # corresponding file of the same name. However, we then strip the
      # separator off to avoid generating adjacent separators in the results.
      if [[ -f "$corresponding" ]]; then
        __go_glob_matches+=("$corresponding")
      fi
      match="${match%/}"
      _@go.glob_files_impl "${match#$__go_glob_files_rootdir/}/*"
    else
      corresponding="${match%$__go_glob_files_suffix}"
      if [[ "$match" != "$corresponding" && ! -d "$corresponding" ]]; then
        __go_glob_matches+=("$match")
      fi
    fi
  done
}

_@go.glob_files_compact_matches() {
  __go_glob_matches=("${__go_glob_matches[@]#$__go_glob_files_rootdir/}")
  __go_glob_matches=("${__go_glob_matches[@]%$__go_glob_files_suffix}")
}

_@go.glob_files_tab_completion() {
  local word_index="$1"
  shift
  local args=("$@")
  local word=("${args[$word_index]}")
  local flags=('--compact' '--ignore')
  local flag='^-'
  local globignore
  local i
  local arg

  for ((i=0; i != ${#args[@]}; ++i)); do
    arg="${args[$i]}"

    case "$arg" in
    --compact)
      unset 'flags[0]'
      ;;
    --ignore)
      if [[ "$word_index" -eq "$((i+1))" ]]; then
        return 1
      fi
      unset 'flags[1]'
      globignore="${args[$((i+1))]}"
      ;;
    *)
      if [[ -d "$arg" ]]; then
        if [[ "$word_index" -lt "$i" ]]; then
          compgen -W "${flags[*]}" -- "$word"
          return
        elif [[ "$word_index" -eq "$((i+1))" ]]; then
          return 1
        fi
        __go_glob_files_rootdir="$arg"
        __go_glob_files_suffix="${args[$((i+1))]}"
        break
      fi
      ;;
    esac

    if [[ "$arg" =~ $flag && "$word_index" -lt "$i" ]]; then
      compgen -W "${flags[*]}" -- "$word"
      return
    fi
  done

  if [[ -z "$__go_glob_files_rootdir" ]]; then
    local err_count=0
    if ! compgen -W "${flags[*]}" -- "$word"; then
      ((++err_count))
    fi
    if ! compgen -d -- "$word"; then
      ((++err_count))
    fi
    return $((err_count != 2 ? 0 : 1))
  fi

  _@go.glob_files_set_globignore "$globignore"
  local __go_glob_matches=()
  _@go.glob_files_impl "$word*"
  _@go.glob_files_compact_matches

  local num_matches="${#__go_glob_matches[@]}"

  if [[ "$num_matches" -eq '0' ]]; then
    return 1
  elif [[ "$num_matches" -eq '1' ]]; then
    echo "${__go_glob_matches[0]}"
    return
  fi

  local prefix="${__go_glob_matches[0]}"
  local prefix_len="${#prefix}"
  local match

  for match in "${__go_glob_matches[@]}"; do
    while [[ "${match:0:$prefix_len}" != "$prefix" ]]; do
      ((--prefix_len))
      prefix="${prefix:0:$prefix_len}"
    done
    if [[ "$prefix_len" -eq '0' ]]; then
      break
    fi
  done

  local results=()
  local suffix
  local trimmed_suffix

  for match in "${__go_glob_matches[@]}"; do
    suffix="${match:${#prefix}}"
    trimmed_suffix="${suffix%%/*}"

    if [[ "$suffix" != "$trimmed_suffix" ]]; then
      match="${match:0:${#prefix}}${trimmed_suffix}/"
    fi
    if [[ "$match" != "$prev" ]]; then
      results+=("$match")
    fi
    prev="$match"
  done

  local IFS=$'\n'
  echo "${results[*]}"
}

_@go.glob_files_set_globignore() {
  if [[ -n "$*" ]]; then
    local patterns=()
    local IFS=':'
    read -r -a patterns <<<"$*"
    GLOBIGNORE="${patterns[*]/#/$__go_glob_files_rootdir/}"
  fi
}

_@go.glob() {
  local globignore
  local list_compact

  while [[ "${1:0:1}" = '-' ]]; do
    case "$1" in
    --complete)
      # Tab completions
      shift
      _@go.glob_files_tab_completion "$@"
      return
      ;;
    --ignore)
      globignore="$2"
      shift
      shift
      ;;
    --compact)
      list_compact='true'
      shift
      ;;
    *)
      @go.printf "Unknown flag: $1" >&2
      return 1
      ;;
    esac
  done

  local __go_glob_files_rootdir="$1"
  shift

  if [[ -z "$__go_glob_files_rootdir" ]]; then
    @go.printf "Root directory argument not specified.\n" >&2
    return 1
  elif [[ ! -d "$__go_glob_files_rootdir" ]]; then
    @go.printf "Root directory argument %s is not a directory.\n" \
      "$__go_glob_files_rootdir" >&2
    return 1
  fi

  local __go_glob_files_suffix="$1"
  shift

  if [[ -z "$__go_glob_files_suffix" ]]; then
    @go.printf "File suffix argument not specified.\n" >&2
    return 1
  fi

  local pattern
  local __go_glob_matches
  local results=()

  _@go.glob_files_set_globignore "$globignore"

  for pattern in "${@:-*}"; do
    __go_glob_matches=()
    _@go.glob_files_impl "$pattern"

    if [[ "${#__go_glob_matches[@]}" -eq '0' ]]; then
      @go.printf "\"$pattern\" does not match any %s files in %s.\n" \
        "$__go_glob_files_suffix" "$__go_glob_files_rootdir" >&2
      return 1
    fi
    results+=("${__go_glob_matches[@]}")
  done

  __go_glob_matches=("${results[@]}")
  if [[ "$list_compact" = 'true' ]]; then
    _@go.glob_files_compact_matches
  fi

  local IFS=$'\n'
  echo "${__go_glob_matches[*]}"
}

_@go.glob "$@"
